#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language ngerman
\language_package default
\inputencoding auto
\fontencoding global
\font_roman Cambria
\font_sans Calibri
\font_typewriter Consolas
\font_default_family default
\use_non_tex_fonts true
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement H
\paperfontsize default
\spacing other 1.2
\use_hyperref true
\pdf_title "Entwicklung auf Windows Phone 7"
\pdf_author "Martin Rauscher"
\pdf_keywords "Windows Phone 7, WP7, XAML, Silverlight, Microsoft"
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 1
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Entwicklung auf Windows Phone 7
\begin_inset Newline newline
\end_inset


\size large
Am Beispiel einer 
\noun on
OpenStreetMap
\noun default
 Anwendung
\end_layout

\begin_layout Author
Martin Rauscher
\end_layout

\begin_layout Section
Einführung
\end_layout

\begin_layout Standard
Laber laber laber
\end_layout

\begin_layout Subsection
Vorstellung der Beispielanwendung
\end_layout

\begin_layout Standard
Im Rahmen dieser Arbeit wurde eine Anwendung erstellt, die das Betrachten
 von Karten von 
\noun on
OpenStreetMap
\noun default
 (und anderen Anbietern) ermöglicht.
 Sie ermöglicht die Steuerung über die üblichen Multi-Touch-Gesten, das
 suchen nach Orten und das erstellen von Favoritenlisten.
 Desweiteren können Routen geplant werden.
\end_layout

\begin_layout Standard
Alle Beispiele in dieser Arbeit sind aus dem Code dieser Anwendung.
 Für nähere Informationen zur 
\begin_inset Quotes eld
\end_inset

OpenStreetApp
\begin_inset Quotes erd
\end_inset

 wird auf 
\begin_inset CommandInset citation
LatexCommand cite
key "HS-Flo"

\end_inset

 verwiesen.
\end_layout

\begin_layout Subsection
Rahmen dieser Arbeit
\end_layout

\begin_layout Standard
Um Anwendungen für WP7 zu schreiben gibt es grundsätzlich zwei Möglichkeiten
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Für spezielle Microsoft Partner ist es auch noch möglich halb-native Anwendungen
 zu schreiben.
\end_layout

\end_inset

:
\end_layout

\begin_layout Enumerate
Entwicklung auf Basis von Silverlight
\end_layout

\begin_layout Enumerate
Nutzung des XNA Framework - eine gekapselte DirectX-Schnittstille - welches
 hauptsächlich für die Entwicklung von Spielen verwendet wird.
\end_layout

\begin_layout Standard
Diese Arbeit beschäftigt sich ausschließlich mit der Entwicklung mit Silverlight
, da das Entwicklungsmodell mit XNA gänzlich anders ist und es nur in seltenen
 Fällen Sinn macht mit XNA nicht-Spiele zu entwickeln.
\end_layout

\begin_layout Section
Windows Phone 7
\end_layout

\begin_layout Standard
Windows Phone 7 ist hinsichtlich der Benutzeroberfläche als auch der Anwendungsp
lattform ein vollständige Neuentwicklung.
 Der Kern des Betriebssystems hingegen ist eine veränderte Version von Windows
 EC 7.0, dem Nachfolger von Windows CE 6, worauf Windows Mobile 6.5 beruht.
\end_layout

\begin_layout Standard
Gründe nicht auf das bestehende Windows Mobile aufzusetzen waren [XXXX]
\end_layout

\begin_layout Itemize
UI-Konzept zu stark Desktoporientiert 
\end_layout

\begin_layout Itemize
Fehlende Multi-Touch Unterstützung
\end_layout

\begin_layout Itemize
Entwicklung moderner Anwendungen schwierig
\end_layout

\begin_layout Standard
WP7 begegnet diesen Problemen mit einer starken Unterstützung für Multi-Touch
 in Silverlight und den integrierten Kontrollelementen, die es leicht machen
 sollen, moderne Anwendungen zu schreiben, die sich in das UI Konzept einfügen.
\end_layout

\begin_layout Section

\noun on
Silverlight
\noun default
 und die
\begin_inset Newline newline
\end_inset


\noun on
Windows
\begin_inset space ~
\end_inset

Presentation
\begin_inset space ~
\end_inset

Foundation
\end_layout

\begin_layout Standard
Das Framework auf WP7 Handys basiert auf dem - vom Desktop bekannten - 
\noun on
Silverlight
\noun default
, welches wiederum auf der 
\noun on
Windows Presentation Foundation
\noun default
 basiert.
 In den folgen Abschnitten soll kurz aufgezeigt werden, wie die beiden Framework
s entstanden sind und was die groben Unterschiede sind.
\end_layout

\begin_layout Subsection

\noun on
Windows Presentation Foundation (WPF)
\end_layout

\begin_layout Standard
Ende 2006 stellte Microsoft die finale Version 3.0 des .NET Framwork vor.
 Mit diesem wurde zum ersten mal die, bis dahin unter dem Codenamen Avalon
 entwickelte, 
\noun on
Windows Presentation Foundation (WPF)
\noun default
 der Öffentlichkeit zugänglich gemacht.
 Microsoft hoffte das Entwickler, insbesondere für das nur zwei Monate später
 erscheinende Windows Vista, nun hauptsächlich mit .NET und WPF entwickeln
 würden.
 Bis heute ist allerdings die Akzeptanz von WPF im Consumerbereich eher
 gering.
\end_layout

\begin_layout Standard
Mit WPF führte Microsoft erstmals ein deklaratives Modell zur Gestaltung
 von Benutzeroberflächen ein.
 Dabei wird die GUI und die Datenbindungen mit einem auf XML basierenden
 Format beschrieben.
 Dies erhöht die Wartbarkeit und Wiederverwendbarkeit verglichen mit den
 bisher verwendeten, zum Teil riesigen, automatisch generierten Funktionen
 enorm.
\end_layout

\begin_layout Standard
Eine weitere große Neuerung ist die Abwendung von GDI(+) für das GUI-Rendering.
 Mit WPF wird erstmals voll auf (hardwarebeschleunigtes) DirectX gesetzt.
 Das hat den Vorteil, dass komplexe Oberflächen gerendert, transformiert
 und mit Effekten versehen werden können, ohne dass die CPU zusätzlich belastet
 wird.
\end_layout

\begin_layout Subsection

\noun on
Silverlight 
\noun default
(WPF/E)
\end_layout

\begin_layout Standard
2007 stellte Microsoft 
\noun on
Silverlight
\noun default
 (unter dem Codenamen Windows 
\noun on
Presentation Foundation/Everywhere 
\noun default
(WPF/E) entwickelt) vor.
 Silverlight ist, plakativ gesprochen, eine stark reduziert Version des
 .NET Framework und eine Untermenge
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Aufgrund von unterschiedlichen Releasezyklen hat die aktuelle WPF einige
 Klassen nicht, die in Silverlight enthalten sind.
 Dies wurden aber über ein Silverlight Toolkit nachgereicht.
\end_layout

\end_inset

 der WPF Funktionalität.
 
\end_layout

\begin_layout Standard
Auch wenn Silverlight oft als Konkurenz zu Adobes Flash Player gesehen wird,
 wurde es hauptsächlich mit dem Ziel entwickelt so genannte Rich Internet
 Applications (RIAs) zu ermöglichen, die hauptsächlich im Geschäftsbereich
 ihren Einsatzzweck haben.
 Der einzige Bereich in dem Silverlight momentan tatsächlich in direkter
 Konkurrenz zu Flash steht ist die Videowiedergabe.
 Sowohl 
\noun on
Smooth Streaming
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Bei Smooth Streaming handelt es sich um eine Technik die Videomaterial dynamisch
 neu kodiert, um sich der zur Verfügung stehenden Bandbreite anzupassen.
\end_layout

\end_inset


\noun default
 als auch hardwarebeschleunigte Videowiedergabe waren zuerst in Silverlight
 möglich.
 Deshalb hat Microsoft einige prominente Unterstützter gefunden: U.a.
 wurden die Olympischen Winterspiele von 2008 und einige amerikanische Sportgroß
ereignisse exklusiv via Silverlight gestreamt; außerdem setzt das deutsche
 Videoportal 
\begin_inset Quotes eld
\end_inset

Maxdome
\begin_inset Quotes erd
\end_inset

 auf Silverlight.
\end_layout

\begin_layout Standard
Silverlight wurde vom Grund auf Plattformunabhängig konzipiert.
 Microsoft stellt es für die meisten Windows Versionen sowie für Mac OS
 X zur Verfügung.
 Desweiteren ist ein Großteil der Spezifikationen und einige Teile des Codes
 öffentlich zugänglich.
 Darauf aufbauend entwickelt das Mono Projekt unter Leitung von Novell einen
 Linux Port.
 
\begin_inset Quotes eld
\end_inset

Moonlight
\begin_inset Quotes erd
\end_inset

 ist momentan Kompatibel mit Silverlight 3.
\end_layout

\begin_layout Subsection
Unterschiede
\end_layout

\begin_layout Standard
nochmal
\end_layout

\begin_layout Standard
Mit dem Ziel der Plattformunabhängigkeit gingen natürlich auch höhere Ansprüche
 an einen geringen Ressourcenverbrauch einher.
 Das hatte zur Folge, dass einige Funktionen - z.B.
 Hardwarebeschleunigung und einige Controls - erst in späteren Versionen
 zur Verfügung standen.
 Bis jetzt sind noch einige Konzepte, wie z.B.
 Trigger und implizite Styles, noch immer nur in WPF verfügbar.
\end_layout

\begin_layout Section
Entwicklen mit Silverlight
\end_layout

\begin_layout Subsection
Struktur einer Silverlight Anwendung
\end_layout

\begin_layout Standard
Eine Silverlight Anwendung wird immer in Form einer in 
\begin_inset Quotes eld
\end_inset

*.XAP
\begin_inset Quotes erd
\end_inset

 umbenannten ZIP-Datei verteilt.
 In dieser Datei sind die vier Bestandteile einer App untergebracht: 
\end_layout

\begin_layout Itemize
Das Manifest (WMAppManifest.xml), welches die Fähigkeiten der App festlegt.
\end_layout

\begin_layout Itemize
Das Anwendungsobjekt (App.cs und App.xaml), welches die zentrale Steuereinheit
 bildet
\end_layout

\begin_layout Itemize
Die verschiedenen 
\begin_inset Quotes eld
\end_inset

Seiten
\begin_inset Quotes erd
\end_inset

 der App
\end_layout

\begin_layout Itemize
Die Ressourcen (Bilder, Töne, etc.)
\end_layout

\begin_layout Standard
Wenn das Betriebssystem eine App startet, wird zuerst das Manifest eingelesen
 und daraus ein xxxxxxx
\end_layout

\begin_layout Standard
navigation
\end_layout

\begin_layout Subsection
XAML
\end_layout

\begin_layout Standard
XAML ist eine deklarative Sprache zur Beschreibung von Datenstrukturen die
 insbesondere in Silverlight und WPF Benutzeroberflächen verwendet wird.
 Sie ist ein XML Dialekt, der um verschiedene Konzepte erweitert wurde:
\end_layout

\begin_layout Subsubsection
Komplexe Attributdefinitionen
\end_layout

\begin_layout Standard
In XML können Attributen nur Strings, Zahlen und Referenzen zugewiesen werden,
 während der Inhalt von Element beliebig komplex sein kann.
 In XAML können Attribute durch eine simple Erweiterung der Semantik von
 Elementnamen, ebenfalls beschrieben werden.
 Im Beispiel 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Beispiel-für-Komplexe"

\end_inset

 wird so auf das Attribut 
\family typewriter
Background
\family default
 über 
\family typewriter
Grid.Background
\family default
 zugegriffen.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=XML,tabsize=4"
inline false
status open

\begin_layout Plain Layout

<Grid Background="Transparent"/>
\end_layout

\begin_layout Plain Layout

<!-- oder -->
\end_layout

\begin_layout Plain Layout

<Grid>
\end_layout

\begin_layout Plain Layout

	<Grid.Background>
\end_layout

\begin_layout Plain Layout

		<SolidColorBrush Color="Transparent"/>
\end_layout

\begin_layout Plain Layout

	</Grid.Background>
\end_layout

\begin_layout Plain Layout

</Grid>
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:Beispiel-für-Komplexe"

\end_inset

Beispiel für Komplexe Attributdefinitionen
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Attached Properties
\end_layout

\begin_layout Standard
Insbesondere bei der Beschreibung von Benutzeroberflächen steht man oft
 vor dem Problem, dass Elemente eine Eigenschaft besitzen, die nur innerhalb
 eines bestimmten Kontext sinnvoll sind.
 
\end_layout

\begin_layout Standard
Z.B.
 hat ein Button der in einem Canvas angeordnet ist eine X und eine Y Koordinate.
 Wird er aber außerhalb eines Canvas eingesetzt sind die Eigenschaften u.U.
 ohne Bedeutung.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=XML,tabsize=4"
inline false
status open

\begin_layout Plain Layout

<Canvas>
\end_layout

\begin_layout Plain Layout

	<Button Canvas.Top="100">
\end_layout

\begin_layout Plain Layout

		<Canvas.Left>25</Canvas.Left>
\end_layout

\begin_layout Plain Layout

		<TextBlock Text="Ein Knopf"/>
\end_layout

\begin_layout Plain Layout

	</Button>
\end_layout

\begin_layout Plain Layout

</Canvas>
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:Bsp-Attached-Property"

\end_inset

Beispiel für ein Attached Property
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
XAML bietet für dieses Problem eine einfache Lösung: Genau wie bei den komplexen
 Attributdefinitionen wird der Name des übergeordneten Elements verwendet
 um die Herkunft des Attributs zu qualifizieren.
 Der Wert des Attributs wird dabei in einem statischen Attribut der Klasse
 des übergeordneten Elements gespeichert.
\end_layout

\begin_layout Subsubsection
Markup Extensions
\end_layout

\begin_layout Standard
Markup Extensions sind ein Konzept, dass es ermöglicht den XAML Parser in
 begrenztem Umfang zu erweitern, so dass die Verwendung komplexer Attributdefini
tionen entfallen kann.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
lstparams "language=XML"
inline false
status open

\begin_layout Plain Layout

<TextBlock Text="{StaticResource AppName}" />
\end_layout

\begin_layout Plain Layout

<!-- oder -->
\end_layout

\begin_layout Plain Layout

<TextBlock Text="{StaticResource ResourceKey=AppName}" />
\end_layout

\begin_layout Plain Layout

<!-- vs.
 -->
\end_layout

\begin_layout Plain Layout

<TextBlock>
\end_layout

\begin_layout Plain Layout

	<TextBlock.Text>
\end_layout

\begin_layout Plain Layout

		<StaticResource ResourceKey="AppName" />
\end_layout

\begin_layout Plain Layout

	</TextBlock.Text>
\end_layout

\begin_layout Plain Layout

</TextBlock>
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:Bsp-Markup-Extension"

\end_inset

Beispiel für eine Markup Extension
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Markup Extensions werden durch führende und endende geschweifte Klammern
 gekennzeichnet.
 Das erste Wort in den Klammern gibt die Klasse der zu verwendenden Extension
 an.
 Parameter werden nach dem Klassennamen gelistet und werden in der Form
 
\begin_inset Quotes eld
\end_inset

Parameter=Wert
\begin_inset Quotes erd
\end_inset

 angegeben.
 Einzige Ausnahme ist der Standardparameter, der ohne Angabe seines Namens
 verwendet werden kann.
 Im Beispiel 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Bsp-Markup-Extension"

\end_inset

 ist der Standardparameter 
\begin_inset Quotes eld
\end_inset

ResourceKey
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Silverlight bietet - in der aktuellen Version - keine Möglichkeit eigene
 Markup Extensions zu definieren.
 Es sind nur die folgenden drei vordefiniert: Binding, StaticResource, DynamicRe
source.
 Auf deren Bedeutung wird im folgenden Abschnitt eingegangen.
\end_layout

\begin_layout Subsection
Datenbindung
\end_layout

\begin_layout Standard
Ein der größten Stärken von Silverlight ist die Möglichkeit Eigenschaften
 von Elementen auf einfache Weise an Attribute von Datenobjekten oder an
 Eigenschaften anderer GUI Elemente zu binden.
 Somit muss keine Code geschrieben werden um die Benutzeroberfläche bei
 Änderungen an den Daten aktuell zu halten.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<TextBox Text="{Binding Path=Vorname, Mode=TwoWay, Converter={StaticResource
 conv1}}"/>
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:Bsp-Binding"

\end_inset

Beispiel für eine Datenbindung
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
xxxx Diese Eigenschaft enthält den aktuellen Kontext für Datenbindungen.
 In Beispiel 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Bsp-Binding"

\end_inset

 kann man sehen wie die Definition einer Datenbindung mit Hilfe der {Binding}
 Markup Extension aussieht.
 Dabei bezieht sich die Datenbindung auf das Objekt das der aktuelle Datenkontex
t ist, da nichts anderes angegeben wurde.
 Dieser Kontext ergibt sich aus dem Element innerhalb dessen das Binding
 definiert wurde.
 Jedes GUI-Element
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Genauer, jede von 
\noun on
FrameworkElement
\noun default
 erbende Klasse.
\end_layout

\end_inset

 hat eine 
\noun on
DataContext
\noun default
 Eigenschaft, die es an eventuell vorhandene Kind-Elemente weitervererbt.
 
\end_layout

\begin_layout Subsubsection
Dependency Properties
\end_layout

\begin_layout Standard
Ein Problem vieler Datenbindungs-Ansätze ist, dass sie Reflection
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Reflection bezeichnet die Möglichkeit Objekte einer statisch getypten Sprache
 zur Laufzeit dynamisch zu untersuchen und zu verändern.
 Hierfür sind meistens aufwendige Aufrufe an die zu Grunde liegende Plattform
 zu richten.
\end_layout

\end_inset

 verwenden, da die Eigenschaften oft als String angegeben werden.
 Außerdem muss jede Klasse typischerweise ein Interface implementieren,
 dass die eventuellen Ziele einer Datenbindung benachrichtigt.
 
\end_layout

\begin_layout Standard
In Silverlight wird dieses Problem mit so genannten Depenency Properties
 (DPs) gelöst.
 Im Grunde sind DPs Dictionaries die als statische Eigenschaften in der
 Klasse definiert werden.
 Dieses weißt dann einem Objekt einen Wert zu.
\end_layout

\begin_layout Standard
Der große Vorteil von DPs ist, dass sich beliebige Objekt registrieren können,
 um benachrichtigt zu werden, wenn sich der Wert einer Eigenschaft eines
 bestimmten Objekts ändert; und zwar mit statisch getypten Vorher-Nachher-Werten.
\end_layout

\begin_layout Standard
Außerdem lassen sich einfach Standardwerte definieren und automatisches
 Vererben von Werten auf Kind-Objekte realisieren.
\end_layout

\begin_layout Subsubsection
Data Templates
\end_layout

\begin_layout Standard
xxxxx
\end_layout

\begin_layout Subsubsection
Converters
\end_layout

\begin_layout Standard
Es ist oft wünschenswert zwei Eigenschaften miteinander zu verbinden, die
 nicht den gleichen Datentyp haben.
 Das typische Beispiel hierfür ist die Text Eigenschaft eines Textblocks
 und ein Zahlwert eines Objekts.
 Im Gegensatz zu diesem einfachen Beispiel, bei dem die Konvertierung natürlich
 automatisch passiert, ist es oft komplizierter.
 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
lstparams "language={[Sharp]C},tabsize=3"
inline false
status open

\begin_layout Plain Layout

public class VisibilityConverter : IValueConverter
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	public Object Convert(Object value, 
\end_layout

\begin_layout Plain Layout

						Type targetType, 
\end_layout

\begin_layout Plain Layout

						Object parameter, 
\end_layout

\begin_layout Plain Layout

						System.Globalization.CultureInfo culture)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return (bool)value == true ? 
\end_layout

\begin_layout Plain Layout

				System.Windows.Visibility.Visible 
\end_layout

\begin_layout Plain Layout

				: System.Windows.Visibility.Collapsed;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public Object ConvertBack(Object value, 
\end_layout

\begin_layout Plain Layout

							Type targetType, 
\end_layout

\begin_layout Plain Layout

							Object parameter,
\end_layout

\begin_layout Plain Layout

							System.Globalization.CultureInfo culture)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		return (System.Windows.Visibility)value 
\end_layout

\begin_layout Plain Layout

			== System.Windows.Visibility.Visible;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:Bsp-Converter"

\end_inset

Beispiel für einen Converter
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Die Lösung dieses Problems sind so genannte Converter, die beliebige Typen
 in einander konvertieren können.
 Converter sind Klassen, die das IValueConverter Interface implementieren.
 Im Beispiel 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Bsp-Converter"

\end_inset

 kann man exemplarisch sehen, wie ein Wahrheitswert in einen Aufzählungstyp
 - und umgekehrt - umgewandelt werden kann.
 Mit Hilfe der Convert und ConvertBack Methoden kann beliebig komplexer
 Code dazu verwendet werden Werte umzuwandeln.
 
\end_layout

\begin_layout Subsection
Resourcen
\end_layout

\begin_layout Standard
In jedem Projekt tauchen Teile auf, die an vielen Stellen wieder verwendet
 werden.
 Z.B.
 Bilder, Texte oder Vorlagen für bestimmte Stile.
 Ähnlich dem Konzept der Datenbindungen können in Silverlight Ressourcen
 einfach definiert und verwendet werden.
\end_layout

\begin_layout Standard
Jedes Steuerelement in Silverlight kann eine List von Ressourcen für sich
 und seine Kindelemente definieren.
 Außerdem können Anwendungsweite Ressourcen definiert werden - siehe Beispiel
 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Bsp-Resourcendefinition"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

<Application.Resources>
\end_layout

\begin_layout Plain Layout

	<System:String x:Key="AppTitle">Open Street App</System:String>
\end_layout

\begin_layout Plain Layout

</Application.Resources>
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:Bsp-Resourcendefinition"

\end_inset

Beispiel Resourcendefinition
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In Beispiel 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Bsp-Binding"

\end_inset

 kann man sehen, wie auf eine Ressource innerhalb einer Datenbindungs-Definition
 verwiesen wird.
 Bei der Auflösung des Namens einer Ressource wird der Elementbaum von unten
 nach oben durchsucht, bis schlussendlich noch die anwendungsweiten Ressourcen
 durchsucht werden.
\end_layout

\begin_layout Standard
In den bisherigen Beispielen erfolgte der Verweise auf eine Ressource immer
 mittels {StaticResource}.
 Erwartungsgemäß existiert auch eine {DynamicResource}.
 Der Unterschied besteht im Ladeverhalten:
\end_layout

\begin_layout Standard
Statische Ressourcen werden nur ein mal beim Initialisieren des Elements
 geladen.
 Sollte sich also das worauf sich die Ressource bezieht verändern, würde
 das die Bindung nicht widerspiegeln.
 Ein dynamischer Ressourcenverweis hingegen funktioniert genau wie eine
 Datenbindung.
\end_layout

\begin_layout Subsection
Besonderheiten auf dem Handy
\end_layout

\begin_layout Standard
Die Entwicklung auf Mobilgeräten unterliegt zum Teil gänzlich anderen Anforderun
gen, als die Entwicklung für den Desktopbereich.
 Diese Unterschiede sind größtenteils nicht WP7 spezifisch, müssen hier
 aber dennoch erwähnt werden, da WP7 einige individuelle Lösungsansätze
 bietet.
\end_layout

\begin_layout Subsubsection
Performance
\end_layout

\begin_layout Standard
Während auf 
\begin_inset Quotes eld
\end_inset

normalen
\begin_inset Quotes erd
\end_inset

 PCs sowohl Rechenleistung als auch Arbeitsspeicher im Überfluss vorhanden
 ist, müssen sich Entwickler im mobilen Bereich über diese Aspekte wieder
 Gedanken machen.
 Nur dann kann eine ausreichende Performance auf dem Gerät zu erzielt werden.
\end_layout

\begin_layout Standard
Dieses Ziel lässt sich auf zwei verschiedene Weise erreichen: Entweder schränkt
 man sich soweit ein, dass die Performance des Gerätes ausreicht oder man
 beeinflusst die wahrgenommene Performance.
 Letzteres beschreibt die Tatsache, dass einem Anwender eine App die ihn
 warten lässt, bis alle Daten geladen sind sehr viel langsamer vorkommt,
 als eine App die ihm wären des Ladevorgangs zumindest schon einzelne Daten
 anzeigt.
 Und das obwohl diese meistens insgesamt sogar länger braucht als erstere.
 Um die wahrgenommene Performance zu verbessern gibt es abhängig von der
 Situation verschiedene Möglichkeiten:
\end_layout

\begin_layout Standard
Wenn eine lange Liste an Daten über eine langsame Handy Verbindung übertragen
 werden soll bietet es sich an, die Daten in kleinen Blöcken zu laden, und
 erst dann den nächsten Block zu laden, wenn der Benutzer an das Ende der
 List gescrollt hat.
\end_layout

\begin_layout Standard
Sobald man die lange List im Speicher hat steht man allerdings vor dem Problem,
 dass die Scroll-Performance stark leidet - besonders bei komplexen Daten
 Templates.
 Silverlight hat für dieses Problem bereits eine eingebaute Lösung (falls
 man die normale ListBox verwendet) mit Namen 
\begin_inset Quotes eld
\end_inset

UI Virtualisierung
\begin_inset Quotes erd
\end_inset

.
 Dabei werden die Daten-Container, die aus dem sichtbaren Bereich heraus-gescrol
lt werden wiederverwendet für die nachfolgenden Daten.
 Somit wird aufwendiges Zuweisen von neuem Speicher vermieden, und es müssen
 keine Container für alle Daten-Elemente erzeugt werden.
\end_layout

\begin_layout Standard
Falls dieser Trick nicht ausreicht um ein flüssiges Scrollen zu ermöglichen,
 weil die Daten Templates zu komplex sind, gibt es ein auch dafür eine Lösung
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Das benötigte Steuerelement ist nicht Teil der Standardbibliothek und kann
 hier gefunden werden: 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://goo.gl/14H2U
\end_layout

\end_inset


\end_layout

\end_inset

.
 In einem erweiterten ListBox Steuerelement ist es möglich ein alternatives,
 vereinfachtes Data Template anzugeben, das verwendet wird, während der
 Benutzer scrollt.
 So kann z.B.
 während des Scrollens nur der Name eines Films angezeigt werden und sobald
 die Liste angehalten wird, auch ein Bild und weitere Informationen.
\end_layout

\begin_layout Subsubsection

\noun on
Tombstoning
\end_layout

\begin_layout Standard
Eine Konsequenz der geringen Ressourcen ist das so genannte 
\noun on
Tombstoning
\noun default
.
 WP7 unterstützt kein Multitasking
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Das OS selbst unterstützt Multitasking und ein zukünftiges Update soll es
 auch Apps zugänglich machen.
\end_layout

\end_inset

, wie man es auf dem Desktop gewöhnt ist.
 Stattdessen wird ein Programm sobald es inaktiv wird aus dem RAM entfernt.
 Bevor dies geschieht wird der App zuvor die Möglichkeit gegeben ihren Zustand
 zu sichern.
\end_layout

\begin_layout Standard
Dies geschieht an zwei Stellen:
\end_layout

\begin_layout Standard
Zum einen kann jede Page lokale Daten halten.
 Da Pages bei jedem Aufruf neu erstellt werden, müssen diese Daten, für
 eine eventuell später ausgeführte 
\begin_inset Quotes eld
\end_inset

zurück
\begin_inset Quotes erd
\end_inset

 Navigation, bei jedem Verlassen gespeichert werden.
 Dies geschieht durch setzen eines 
\noun on
State
\noun default
 Dictionaries, auf das der Navigationsservice Zugriff hat.
 
\end_layout

\begin_layout Standard
Zum Anderen kann die 
\noun on
App
\noun default
 Klasse globale Daten halten.
 Diese können entweder auch mit einer Dictionary basierten Methode gespeichert
 werden, oder aber auch manuell mit dem normalen Dateisystem.
\end_layout

\begin_layout Standard
Wenn eine Anwendung oder eine Seite keinen inhärenten Zustand hat, ist die
 Verwendung dieser Methoden aber nicht verpflichtend.
 Sie werden dann einfach neu erstellt, wie beim ersten Aufruf.
\end_layout

\begin_layout Subsubsection
UI Design
\end_layout

\begin_layout Standard
Ein weiterer Aspekt, auf den hier aber nicht näher eingegangen werden soll,
 ist die Bauform.
 Durch sie bedingt steht sehr viel weniger Bildschirmfläche zur Verfügung,
 was u.U.
 ein Komplett unterschiedliches Design von Nöten machen kann.
 Außerdem sind in diesem Bereich Eingabemethoden üblich, die auf dem Desktop
 oft garnicht zur Verfügung stehen.
 (Z.B.
 Multi-Touch-Screens, Beschleunigungs- und Lagesensoren)
\end_layout

\begin_layout Subsection
Entwicklungsumgebung
\end_layout

\begin_layout Standard
Visual Studio
\end_layout

\begin_layout Section
Fazit - Erfolgschancen von WP7
\end_layout

\begin_layout Standard
noch-probleme
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "HS-Refs"
options "bibtotoc,plainnat"

\end_inset


\end_layout

\end_body
\end_document
